import{_ as ye}from"./preload-helper-41c905a7.js";import{t as G,r as N}from"./typedArrayUtil-70e1d79e.js";import{l as H,b as Me,r as Ce,d as Ne}from"./Polyline-cf51ad23.js";import{s as ne}from"./quantizationUtils-5accf704.js";import{H as qe,Q as Ge,E as q,i as xe,x as K,I as X,X as Pe,m as Oe,U as re}from"./Extent-2ad2c9a9.js";import{a as A}from"./Error-62cc7aff.js";import{e as oe}from"./ItemCache-47345b61.js";import{f as Ze}from"./WhereClause-ec2695a9.js";import{c as B,x as je,m as Be,f as le,d as ue,V as Qe,T as Ue,F as Le,D as He,N as Xe,S as Ye,v as ke,p as Je}from"./utils-eec406bb.js";import{l as _e,_ as Ke,A as We}from"./projection-d42b91be.js";import{t as Fe}from"./json-48e3ea08.js";import{C as et}from"./JSONSupport-32b5ad86.js";import{v as tt,u as Ie,y as it,f as st}from"./jsonUtils-6d0a72e3.js";import{v as at}from"./normalizeUtils-11faac16.js";import{g as nt,m as Y,M as rt,j as k,C as ot,K as lt,q as ut}from"./featureConversionUtils-66a9b1ed.js";import{t as W}from"./OptimizedFeature-cb86a86f.js";import{t as ce}from"./fieldUtils-e397be4b.js";import{i as ct}from"./arcadeOnDemand-5c3ab3f7.js";function dt(a,t,e){return{objectId:a,target:t,distance:e,type:"vertex"}}function ft(a,t,e,i,s,n=!1){return{objectId:a,target:t,distance:e,type:"edge",start:i,end:s,draped:n}}let ht=class{constructor(t,e){this._cache=new oe(t),this._invalidCache=new oe(e)}get(t,e){const i=`${e.uid}:${t}`,s=this._cache.get(i);if(s)return s;if(this._invalidCache.get(i)!==void 0)return null;try{const n=Ze.create(t,e);return this._cache.put(i,n),n}catch{return this._invalidCache.put(i,null),null}}};const ee=new ht(50,500),D="feature-store:unsupported-query",Ve=" as ",mt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Ut(a,t){if(!t)return!0;const e=ee.get(t,a);if(!e)throw new A(D,"invalid SQL expression",{where:t});if(!e.isStandardized)throw new A(D,"where clause is not standard",{where:t});return te(a,e.fieldNames,"where clause contains missing fields"),!0}function Lt(a,t,e){if(!t)return!0;const i=ee.get(t,a);if(!i)throw new A(D,"invalid SQL expression",{having:t});if(!i.isAggregate)throw new A(D,"having does not contain a valid aggregate function",{having:t});const s=i.fieldNames;if(te(a,s,"having contains missing fields"),!i.getExpressions().every(n=>{var u;const{aggregateType:o,field:r}=n,l=(u=a.get(r))==null?void 0:u.name;return e.some(c=>{var f;const{onStatisticField:h,statisticType:m}=c;return((f=a.get(h))==null?void 0:f.name)===l&&m.toLowerCase().trim()===o})}))throw new A(D,"expressions in having should also exist in outStatistics",{having:t});return!0}function C(a,t){return a?ee.get(a,t):null}function te(a,t,e,i=!0){const s=[];for(const n of t)if(n!=="*"&&!a.has(n))if(i){const o=Se(n);try{const r=C(o,a);if(!r)throw new A(D,"invalid SQL expression",{where:o});if(!r.isStandardized)throw new A(D,"expression is not standard",{clause:r});te(a,r.fieldNames,"expression contains missing fields")}catch(r){const l=r&&r.details;if(l&&(l.clause||l.where))throw r;l&&l.missingFields?s.push(...l.missingFields):s.push(n)}}else s.push(n);if(s.length)throw new A(D,e,{missingFields:s})}function Se(a){return a.split(Ve)[0]}function pt(a){return a.split(Ve)[1]}function Ht(a,t){const e=t.get(a);return!!e&&!mt.has(e.type)}class O{constructor(t,e,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=e;const s=t.outFields;if(s&&!s.includes("*")){this.outFields=s;let n=0;for(const o of s){const r=Se(o),l=this.fieldsIndex.get(r),u=l?null:C(r,i),c=l?l.name:pt(o)||"FIELD_EXP_"+n++;this._fieldDataCache.set(o,{alias:c,clause:u})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){var o;const s=i?i.name:e;let n=null;return this._fieldDataCache.has(s)?n=(o=this._fieldDataCache.get(s))==null?void 0:o.clause:i||(n=C(e,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:n})),i?this.featureAdapter.getAttribute(t,s):n==null?void 0:n.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const i=e.normalizationType,s=e.normalizationTotal;let n=e.field&&this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(n=`${B(n)}${e.fieldDelimiter}${B(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(n=`${n}${e.fieldDelimiter}${B(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(n)){const o=i==="field"&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;n=je(n,i,o,s)}return n}getExpressionValue(t,e,i,s){const n={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},o=s.createExecContext(n,i);return s.executeFunction(e,o)}getExpressionValues(t,e,i,s){const n={fields:this.fieldsIndex.fields};return t.map(o=>{const r={attributes:this.featureAdapter.getAttributes(o),layer:n},l=s.createExecContext(r,i);return s.executeFunction(e,l)})}validateItem(t,e){var i,s;return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:C(e,this.fieldsIndex)}),((s=(i=this._fieldDataCache.get(e))==null?void 0:i.clause)==null?void 0:s.testFeature(t,this.featureAdapter))??!1}validateItems(t,e){var i,s;return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:C(e,this.fieldsIndex)}),((s=(i=this._fieldDataCache.get(e))==null?void 0:i.clause)==null?void 0:s.testSet(t,this.featureAdapter))??!1}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const s of e){const{alias:n,clause:o}=this._fieldDataCache.get(s);i[n]=o?o.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,n)}return i}_processAttributesForDistinctValues(t){if(G(t)||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const o of e){const{alias:r}=this._fieldDataCache.get(o);i.push(t[r])}else for(const o in t)i.push(t[o]);const s=`${(e||["*"]).join(",")}=${i.join(",")}`;let n=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++n),n>1?null:t}}const Q=[0,0];function ve(a,t){if(!t)return null;if("x"in t){const e={x:0,y:0};return[e.x,e.y]=a(t.x,t.y,Q),t.z!=null&&(e.z=t.z),t.m!=null&&(e.m=t.m),e}if("xmin"in t){const e={xmin:0,ymin:0,xmax:0,ymax:0};return[e.xmin,e.ymin]=a(t.xmin,t.ymin,Q),[e.xmax,e.ymax]=a(t.xmax,t.ymax,Q),t.hasZ&&(e.zmin=t.zmin,e.zmax=t.zmax,e.hasZ=!0),t.hasM&&(e.mmin=t.mmin,e.mmax=t.mmax,e.hasM=!0),e}return"rings"in t?{rings:de(t.rings,a),hasM:t.hasM,hasZ:t.hasZ}:"paths"in t?{paths:de(t.paths,a),hasM:t.hasM,hasZ:t.hasZ}:"points"in t?{points:Te(t.points,a),hasM:t.hasM,hasZ:t.hasZ}:null}function de(a,t){const e=[];for(const i of a)e.push(Te(i,t));return e}function Te(a,t){const e=[];for(const i of a){const s=t(i[0],i[1],[0,0]);e.push(s),i.length>2&&s.push(i[2]),i.length>3&&s.push(i[3])}return e}async function we(a,t){if(!a||!t)return;const e=Array.isArray(a)?a.map(i=>N(i.geometry)?i.geometry.spatialReference:null).filter(N):[a];await Ke(e.map(i=>({source:i,dest:t})))}const be=ve.bind(null,qe),Re=ve.bind(null,Ge);function Z(a,t,e,i){if(!a||(e||(e=t,t=a.spatialReference),!X(t)||!X(e)||q(t,e)))return a;if(xe(t,e)){const s=K(e)?be(a):Re(a);return s.spatialReference=e,s}return _e(Fe,[a],t,e,null,i)[0]}let gt=class{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(t,e,i){if(!t||!t.length||!e||!i||q(e,i))return t;const s={geometries:t,inSpatialReference:e,outSpatialReference:i,resolve:null};return this._jobs.push(s),new Promise(n=>{s.resolve=n,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const t=this._jobs.shift();if(!t)return;const{geometries:e,inSpatialReference:i,outSpatialReference:s,resolve:n}=t;xe(i,s)?K(s)?n(e.map(be)):n(e.map(Re)):n(_e(Fe,e,i,s,null,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}};const yt=new gt;function Yt(a,t,e){return yt.push(a,t,e)}const xt=new et({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),fe=Object.freeze({}),he=new W,_t=new W,J=new W,b={esriGeometryPoint:k,esriGeometryPolyline:ot,esriGeometryPolygon:lt,esriGeometryMultipoint:ut};function me(a,t,e,i=a.hasZ,s=a.hasM){if(G(t))return null;const n=a.hasZ&&i,o=a.hasM&&s;if(e){const r=Y(J,t,a.hasZ,a.hasM,"esriGeometryPoint",e,i,s);return k(r,n,o)}return k(t,n,o)}function U(a,t,e,i,s,n,o=t,r=e){var h,m,d;const l=t&&o,u=e&&r,c=N(i)?"coords"in i?i:i.geometry:null;if(G(c))return null;if(s){let f=nt(_t,c,t,e,a,s,o,r);return n&&(f=Y(J,f,l,u,a,n)),((h=b[a])==null?void 0:h.call(b,f,l,u))??null}if(n){const f=Y(J,c,t,e,a,n,o,r);return((m=b[a])==null?void 0:m.call(b,f,l,u))??null}return rt(he,c,t,e,o,r),((d=b[a])==null?void 0:d.call(b,he,l,u))??null}async function kt(a,t,e){const{outFields:i,orderByFields:s,groupByFieldsForStatistics:n,outStatistics:o}=a;if(i)for(let r=0;r<i.length;r++)i[r]=i[r].trim();if(s)for(let r=0;r<s.length;r++)s[r]=s[r].trim();if(n)for(let r=0;r<n.length;r++)n[r]=n[r].trim();if(o)for(let r=0;r<o.length;r++)o[r].onStatisticField&&(o[r].onStatisticField=o[r].onStatisticField.trim());return a.geometry&&!a.outSR&&(a.outSR=a.geometry.spatialReference),Ft(a,t,e)}async function Ft(a,t,e){var n;if(!a)return null;let{where:i}=a;if(a.where=i=i&&i.trim(),(!i||/^1 *= *1$/.test(i)||t&&t===i)&&(a.where=null),!a.geometry)return a;let s=await Vt(a);if(a.distance=0,a.units=null,a.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:o}=a.geometry;s=H(s),s.spatialReference=o}if(s){await we(s.spatialReference,e),s=It(s,e);const o=(await at(tt(s)))[0];if(G(o))throw fe;const r="quantizationParameters"in a&&((n=a.quantizationParameters)==null?void 0:n.tolerance)||"maxAllowableOffset"in a&&a.maxAllowableOffset||0,l=r&&Ae(s,e)?{densificationStep:8*r}:void 0,u=o.toJSON(),c=await Z(u,u.spatialReference,e,l);if(!c)throw fe;c.spatialReference=e,a.geometry=c}return a}function Ae(a,t){if(!a)return!1;const e=a.spatialReference;return(Ie(a)||it(a)||st(a))&&!q(e,t)&&!We(e,t)}function It(a,t){const e=a.spatialReference;return Ae(a,t)&&Ie(a)?{spatialReference:e,rings:[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]]}:a}async function Vt(a){const{distance:t,units:e}=a,i=a.geometry;if(t==null||"vertexAttributes"in i)return i;const s=i.spatialReference,n=e?xt.fromJSON(e):Pe(s),o=s&&(Oe(s)||K(s))?i:await we(s,re).then(()=>Z(i,re));return(await St())(o.spatialReference,o,t,n)}async function St(){return(await ye(()=>import("./geometryEngineJSON-1e940afe.js"),["./geometryEngineJSON-1e940afe.js","./geometryEngineBase-e1a33b0a.js","./geometryEngineJSON-3f330436.js","./json-48e3ea08.js"],import.meta.url)).geodesicBuffer}function L(a){return a&&De in a?JSON.parse(JSON.stringify(a,vt)):a}const De="_geVersion",vt=(a,t)=>a!==De?t:void 0;class Jt{constructor(t,e,i){this.items=t,this.query=e,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new O(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:i,outStatistics:s}=this.query;if(!(e==null?void 0:e.length))return 1;const o=new Map,r=new Map,l=new Set;for(const u of s){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!r.has(h)){const d=[];for(const f of e){const y=this._getAttributeValues(t,f,o);d.push(y)}r.set(h,this._calculateUniqueValues(d,t.returnDistinctValues))}const m=r.get(h);for(const d in m){const{data:f,items:y}=m[d],I=f.join(",");i&&!t.validateItems(y,i)||l.add(I)}}return l.size}async createQueryResponse(){let t;if(this.query.outStatistics?t=this.query.outStatistics.some(e=>e.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):t=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const e=this.query.geometry;X(this.query.outSR)&&!q(e.spatialReference,this.query.outSR)?t.queryGeometry=L({spatialReference:this.query.outSR,...Z(e,e.spatialReference,this.query.outSR)}):t.queryGeometry=L({spatialReference:this.query.outSR,...e})}return t}createSnappingResponse(t,e){const i=this.featureAdapter,s=pe(this.hasZ,this.hasM),{point:n,mode:o}=t,r=typeof t.distance=="number"?t.distance:t.distance.x,l=typeof t.distance=="number"?t.distance:t.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this._getPointCreator(o,this.spatialReference,e),m=new ge(null,0),d=new ge(null,0),f={x:0,y:0,z:0};for(const y of this.items){const I=i.getGeometry(y);if(G(I))continue;const{coords:x,lengths:V}=I;if(m.coords=x,d.coords=x,t.types&j.EDGE){let _=0;for(let F=0;F<V.length;F++){const g=V[F];for(let p=0;p<g;p++,_+=s){const S=m;if(S.coordsIndex=_,p!==g-1){const v=d;v.coordsIndex=_+s;const E=f;Tt(f,n,S,v);const T=(n.x-E.x)/r,w=(n.y-E.y)/l,z=T*T+w*w;z<=1&&u.candidates.push(ft(i.getObjectId(y),h(E),Math.sqrt(z),h(S),h(v)))}}}}if(t.types&j.VERTEX){const _=c?x.length-s:x.length;for(let F=0;F<_;F+=s){const g=m;g.coordsIndex=F;const p=(n.x-g.x)/r,S=(n.y-g.y)/l,v=p*p+S*S;v<=1&&u.candidates.push(dt(i.getObjectId(y),h(g),Math.sqrt(v)))}}}return u.candidates.sort((y,I)=>y.distance-I.distance),u}_getPointCreator(t,e,i){const s=N(i)&&!q(e,i)?r=>Z(r,e,i):r=>r,{hasZ:n}=this,o=0;return t==="3d"?n?({x:r,y:l,z:u})=>s({x:r,y:l,z:u}):({x:r,y:l})=>s({x:r,y:l,z:o}):({x:r,y:l})=>s({x:r,y:l})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,minValue:r,maxValue:l,scale:u}=t,c=this.fieldsIndex.isDateField(e),h=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,scale:u}),m=Be({normalizationType:n,normalizationField:s,minValue:r,maxValue:l}),d=this.fieldsIndex.get(e),f={value:.5,fieldType:d==null?void 0:d.type},y=ce(d)?le({values:h,supportsNullCount:m,percentileParams:f}):ue({values:h,minValue:r,maxValue:l,useSampleStdDev:!n,supportsNullCount:m,percentileParams:f});return Qe(y,c)}async createUniqueValuesResponse(t){const{field:e,valueExpression:i,domains:s,returnAllCodedValues:n,scale:o}=t,r=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:i,scale:o}),l=Ue(r);return Le(l,s,n,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:h,scale:m}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,scale:m}),f=He(d,{field:e,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:h});return Xe(f,r)}async createHistogramResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:h,scale:m}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,scale:m});return Ye(d,{field:e,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:h})}_sortFeatures(t,e,i){if(t.length>1&&e&&e.length)for(const s of e.reverse()){const n=s.split(" "),o=n[0],r=this.fieldsIndex.get(o),l=!!n[1]&&n[1].toLowerCase()==="desc",u=ke(r==null?void 0:r.type,l);t.sort((c,h)=>{const m=i(c,o,r),d=i(h,o,r);return u(m,d)})}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:i,hasM:s,hasZ:n,objectIdField:o,spatialReference:r}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:m,returnZ:d,returnM:f}=t,y=h!=null&&e.length>(m||0)+h,I=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(x=>this.fieldsIndex.get(x)));return{exceededTransferLimit:y,features:this._createFeatures(t,e),fields:I,geometryType:i,hasM:s&&f,hasZ:n&&d,objectIdFieldName:o,spatialReference:L(u||r),transform:c&&ne(c)||null}}_createFeatures(t,e){const i=new O(t,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:n}=this,{orderByFields:o,quantizationParameters:r,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:m,returnZ:d=!1,returnM:f=!1}=t,y=n&&d,I=s&&f;let x=[],V=0;const _=[...e];if(this._sortFeatures(_,o,(g,p,S)=>i.getFieldValue(g,p,S)),l||u){const g=ne(r)??void 0;if(l&&!u)for(const p of _)x[V++]={attributes:i.getAttributes(p),geometry:U(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),c,g,y,I)};else if(!l&&u)for(const p of _)x[V++]={attributes:i.getAttributes(p),centroid:me(this,this.featureAdapter.getCentroid(p,this),g)};else for(const p of _)x[V++]={attributes:i.getAttributes(p),centroid:me(this,this.featureAdapter.getCentroid(p,this),g),geometry:U(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),c,g,y,I)}}else for(const g of _){const p=i.getAttributes(g);p&&(x[V++]={attributes:p})}const F=h||0;if(m!=null){const g=F+m;x=x.slice(F,Math.min(x.length,g))}return x}_createExceedsLimitQueryResponse(t){let e=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const o of t.outStatistics??[])if(o.statisticType==="exceedslimit"){i=o.maxPointCount!=null?o.maxPointCount:Number.POSITIVE_INFINITY,s=o.maxRecordCount!=null?o.maxRecordCount:Number.POSITIVE_INFINITY,n=o.maxVertexCount!=null?o.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>i;else if(this.items.length>s)e=!0;else{const o=pe(this.hasZ,this.hasM),r=this.featureAdapter;e=this.items.reduce((l,u)=>{const c=r.getGeometry(u);return l+(N(c)&&c.coords.length||0)},0)/o>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},i=[],s=new Map,n=new Map,o=new Map,r=new Map,l=new O(t,this.featureAdapter,this.fieldsIndex),u=t.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:m}=t,d=c&&c.length,f=!!d,y=f?c[0]:null,I=f&&!this.fieldsIndex.get(y);for(const V of u??[]){const{outStatisticFieldName:_,statisticType:F}=V,g=V,p=F!=="exceedslimit"?V.onStatisticField:void 0,S=F==="percentile_disc"||F==="percentile_cont",v=F==="EnvelopeAggregate"||F==="CentroidAggregate"||F==="ConvexHullAggregate",E=f&&d===1&&(p===y||I)&&F==="count";if(f){if(!o.has(p)){const w=[];for(const z of c){const P=this._getAttributeValues(l,z,s);w.push(P)}o.set(p,this._calculateUniqueValues(w,!v&&l.returnDistinctValues))}const T=o.get(p);for(const w in T){const{count:z,data:P,items:ie,itemPositions:ze}=T[w],se=P.join(",");if(!h||l.validateItems(ie,h)){const $=r.get(se)||{attributes:{}};if(v){$.aggregateGeometries||($.aggregateGeometries={});const{aggregateGeometries:R,outStatisticFieldName:M}=await this._getAggregateGeometry(g,ie);$.aggregateGeometries[M]=R}else{let R=null;if(E)R=z;else{const M=this._getAttributeValues(l,p,s),ae=ze.map(Ee=>M[Ee]);R=S&&"statisticParameters"in g?this._getPercentileValue(g,ae):this._getStatisticValue(g,ae,null,l.returnDistinctValues)}$.attributes[_]=R}let $e=0;c.forEach((R,M)=>$.attributes[this.fieldsIndex.get(R)?R:"EXPR_"+ ++$e]=P[M]),r.set(se,$)}}}else if(v){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:T,outStatisticFieldName:w}=await this._getAggregateGeometry(g,this.items);e.aggregateGeometries[w]=T}else{const T=this._getAttributeValues(l,p,s);e.attributes[_]=S&&"statisticParameters"in g?this._getPercentileValue(g,T):this._getStatisticValue(g,T,n,l.returnDistinctValues)}i.push({name:_,alias:_,type:"esriFieldTypeDouble"})}const x=f?Array.from(r.values()):[e];return this._sortFeatures(x,m,(V,_)=>V.attributes[_]),{fields:i,features:x}}async _getAggregateGeometry(t,e){const i=await ye(()=>import("./geometryEngineJSON-1e940afe.js"),["./geometryEngineJSON-1e940afe.js","./geometryEngineBase-e1a33b0a.js","./geometryEngineJSON-3f330436.js","./json-48e3ea08.js"],import.meta.url),{statisticType:s,outStatisticFieldName:n}=t,{featureAdapter:o,spatialReference:r,geometryType:l,hasZ:u,hasM:c}=this,h=e.map(f=>U(l,u,c,o.getGeometry(f))),m=i.convexHull(r,h,!0)[0],d={aggregateGeometries:null,outStatisticFieldName:null};if(s==="EnvelopeAggregate"){const f=m?Me(m):H(i.union(r,h));d.aggregateGeometries={...f,spatialReference:r},d.outStatisticFieldName=n||"extent"}else if(s==="CentroidAggregate"){const f=m?Ce(m):Ne(H(i.union(r,h)));d.aggregateGeometries={x:f[0],y:f[1],spatialReference:r},d.outStatisticFieldName=n||"centroid"}else s==="ConvexHullAggregate"&&(d.aggregateGeometries=m,d.outStatisticFieldName=n||"convexHull");return d}_getStatisticValue(t,e,i,s){const{onStatisticField:n,statisticType:o}=t;let r=null;return r=i!=null&&i.has(n)?i.get(n):ce(this.fieldsIndex.get(n))?le({values:e,returnDistinct:s}):ue({values:e,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(n,r),r[o==="var"?"variance":o]}_getPercentileValue(t,e){const{onStatisticField:i,statisticParameters:s,statisticType:n}=t,{value:o,orderBy:r}=s,l=this.fieldsIndex.get(i);return Je(e,{value:o,orderBy:r,fieldType:l==null?void 0:l.type,isDiscrete:n==="percentile_disc"})}_getAttributeValues(t,e,i){if(i.has(e))return i.get(e);const s=this.fieldsIndex.get(e),n=this.items.map(o=>t.getFieldValue(o,e,s));return i.set(e,n),n}_getAttributeDataValues(t,e){return this.items.map(i=>t.getDataValue(i,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal}))}async _getAttributeExpressionValues(t,e,i){const{arcadeUtils:s}=await ct(),n=s.createFunction(e),o=i&&s.getViewInfo(i);return t.getExpressionValues(this.items,n,o,s)}_calculateUniqueValues(t,e){const i={},s=this.items,n=s.length;for(let o=0;o<n;o++){const r=s[o],l=[];for(const c of t)l.push(c[o]);const u=l.join(",");e?i[u]==null&&(i[u]={count:1,data:l,items:[r],itemPositions:[o]}):i[u]==null?i[u]={count:1,data:l,items:[r],itemPositions:[o]}:(i[u].count++,i[u].items.push(r),i[u].itemPositions.push(o))}return i}async _getDataValues(t){const e=new O(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:n,normalizationType:o,normalizationTotal:r,scale:l}=t,u=i?{viewingMode:"map",scale:l,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(e,i,u):this._getAttributeDataValues(e,{field:s,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:n,normalizationType:o,normalizationTotal:r})}}function Tt(a,t,e,i){const s=i.x-e.x,n=i.y-e.y,o=s*s+n*n,r=(t.x-e.x)*s+(t.y-e.y)*n,l=Math.min(1,Math.max(0,r/o));a.x=e.x+s*l,a.y=e.y+n*l}function pe(a,t){return a?t?4:3:t?3:2}var j;(function(a){a[a.NONE=0]="NONE",a[a.EDGE=1]="EDGE",a[a.VERTEX=2]="VERTEX"})(j||(j={}));class ge{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{Jt as A,j as D,L as E,fe as F,Ft as J,Yt as M,Lt as a,Ht as b,te as c,ft as e,we as f,Z as g,C as l,Ut as o,dt as t,U as v,kt as z};
