import{t as c,r,w as T,p as R,e as W}from"./typedArrayUtil-ce39e5f4.js";import{g as q,x as A}from"./promiseUtils-e37fe75d.js";import{l as B}from"./reactiveUtils-042dd05a.js";import{i as J}from"./dehydratedFeatureComparison-d263905a.js";import{aW as K}from"./index-334863ed.js";import{C as Q}from"./InteractiveToolBase-711b78f1.js";import{e as V}from"./SnappingContext-7b0a2e3a.js";import{R as G,D as H}from"./Scheduler-3113abcd.js";import{e as x,v as X,y,a as Y}from"./cast-8b575ab3.js";import"./ArrayPool-5813d861.js";function Pt({predicate:t=()=>!0,snappingManager:n,snappingContext:e,updatingHandles:i,useZ:o=!0}){const s=new Q;if(c(n))return{snappingStep:[E,s],cancelSnapping:E};let l,d=null,a=null,h=null;const f=()=>{d=T(d),n.doneSnapping(),r(a)&&a.frameTask.remove(),a=null,l=R(l),h=null},v=tt(n,o,s);let P=null,u=null,k=null;return{snappingStep:[p=>{if(!t(p))return p;const{action:S}=p;if(S==="start"){const{info:_}=p,w=nt(n.view);if(a=et(e,p,w),a.context.selfSnappingZ=null,!o&&r(_)){const m=it(e.coordinateHelper,_.handle.component);r(m)&&(a.context.selfSnappingZ={value:m,elevationInfo:e.elevationInfo})}}if(r(a)){const{context:_,originalScenePos:w,originalPos:m}=a,{mapEnd:z,mapStart:$,scenePoints:M}=p,C=N(m,Z(z,$)),I=Z($,m),j={...p,action:"update"},D=a.context,b=ot(w,M),O=n.update({point:C,scenePoint:b,context:_});if(k=O,U(z,O,I,o),P=C,u=b,S!=="end"){const{frameTask:F}=a;c(d)&&(d=new AbortController),h=L=>{i.addPromise(q(v({frameTask:F,event:j,context:D,point:C,scenePoint:b,delta:I,getLastState:()=>({point:P,scenePoint:u,updatePoint:L.forceUpdate?null:k})},W(d).signal)))},h({forceUpdate:!1}),c(l)&&(l=B(()=>n.options.effectiveEnabled,()=>h==null?void 0:h({forceUpdate:!0})))}}return S==="end"&&f(),p},s],cancelSnapping:p=>(f(),p)}}function tt(t,n,e){return A(async({frameTask:i,point:o,scenePoint:s,context:l,event:d,delta:a,getLastState:h},f)=>{const v=await i.schedule(()=>t.snap({point:o,scenePoint:s,context:l,signal:f}),f);if(v.valid){let P=await i.schedule(()=>v.apply(),f);const u=h();r(u.point)&&o!==u.point&&(P=t.update({point:u.point,scenePoint:u.scenePoint,context:l})),!c(u.updatePoint)&&J(P,u.updatePoint)||(U(d.mapEnd,P,a,n),e.execute(d))}})}function nt(t){return t.type==="3d"?t.resourceController.scheduler.registerTask(G.SNAPPING):H}function et(t,n,e){return{context:new V({editGeometryOperations:t.editGeometryOperations,elevationInfo:t.elevationInfo,pointer:t.pointer,vertexHandle:r(n.info)?n.info.handle:null,excludeFeature:t.excludeFeature,visualizer:t.visualizer}),originalPos:r(n.snapOrigin)?t.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:r(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:e}}function N(t,[n,e,i]){const o=K(t);return o.x+=n,o.y+=e,o.hasZ&&(o.z+=i),o}function ot(t,n){return c(t)||c(n)?null:N(t,Z(n.sceneEnd,n.sceneStart))}function Z(t,n){const e=t.hasZ&&n.hasZ?t.z-n.z:0;return[t.x-n.x,t.y-n.y,e]}function U(t,n,[e,i,o],s){t.x=n.x+e,t.y=n.y+i,s&&t.hasZ&&n.hasZ&&(t.z=n.z+o)}function it(t,n){if(!t.hasZ())return null;const e=n.vertices;let i=null;for(const o of e){const s=t.getZ(o.pos);if(r(i)&&r(s)&&Math.abs(s-i)>1e-6)return null;c(i)&&(i=s)}return i}function E(t){return t}let g=class extends X{constructor(t){super(t),this.constrainResult=n=>n,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=A(async(n,e,i,o)=>{const s=this._frameTask;if(c(s))return;const l=await s.schedule(()=>e.snap({...n,context:i,signal:o}),o);l.valid&&await s.schedule(()=>{this.stagedPoint=l.apply(),n!==this._snapPoints&&r(this._snapPoints)&&(this.stagedPoint=e.update({...this._snapPoints,context:i}))},o)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(t){this._stagedPoint=this.constrainResult(t)}initialize(){var n,e;const t=this.view.type==="3d"?(e=(n=this.view)==null?void 0:n.resourceController)==null?void 0:e.scheduler:null;this._frameTask=r(t)?t.registerTask(G.SNAPPING):H}destroy(){this._abortController=T(this._abortController),this._frameTask=R(this._frameTask)}update(t,n,e){this._snapPoints=t;const{point:i,scenePoint:o}=t,s=n.update({point:i,scenePoint:o,context:e});return this.stagedPoint=s,s}async snap(t,n,e){const{point:i,scenePoint:o}=t;return this.stagedPoint=n.update({point:i,scenePoint:o,context:e}),this._snapPoints=t,c(this._abortController)&&(this._abortController=new AbortController),this._snap(t,n,e,this._abortController.signal)}async resnap(t,n){c(this._snapPoints)||await this.snap(this._snapPoints,t,n)}abort(){this._abortController=T(this._abortController),this._snapPoints=null}};x([y({constructOnly:!0})],g.prototype,"view",void 0),x([y()],g.prototype,"stagedPoint",null),x([y()],g.prototype,"constrainResult",void 0),x([y()],g.prototype,"_stagedPoint",void 0),g=x([Y("esri.views.interactive.snapping.SnappingOperation")],g);export{g as h,Pt as m};
