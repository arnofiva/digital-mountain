import{s as F,r as W,a as _}from"./Error-62cc7aff.js";import{t as B,r as E}from"./typedArrayUtil-70e1d79e.js";import{m as I,v as P}from"./Polyline-cf51ad23.js";import{r as b,o as j,i as R,s as C}from"./normalizeUtilsCommon-f5194d67.js";import{k as G,b as M,q as H}from"./Extent-2ad2c9a9.js";import"./geometry-f89ca072.js";import{L as T,U as X}from"./request-f01affa1.js";import{c as k,v as K,d as Q}from"./jsonUtils-6d0a72e3.js";import{p as V}from"./string-7a2f1d87.js";function $t(t,n){return n?{...n,query:{...t??{},...n.query}}:{query:t}}function Y(t){return typeof t=="string"?T(t):V(t)}function Z(t,n,u){const s={};for(const e in t){if(e==="declaredClass")continue;const o=t[e];if(o!=null&&typeof o!="function")if(Array.isArray(o)){s[e]=[];for(let r=0;r<o.length;r++)s[e][r]=Z(o[r])}else if(typeof o=="object")if(o.toJSON){const r=o.toJSON(u&&u[e]);s[e]=n?r:JSON.stringify(r)}else s[e]=n?o:JSON.stringify(o);else s[e]=o}return s}async function tt(t,n,u,s){const e=Y(t),o=n[0].spatialReference,r={...s,query:{...e.query,f:"json",sr:JSON.stringify(o),target:JSON.stringify({geometryType:k(n[0]),geometries:n}),cutter:JSON.stringify(u)}},i=await X(e.path+"/cut",r),{cutIndexes:l,geometries:y=[]}=i.data;return{cutIndexes:l,geometries:y.map(h=>{const d=K(h);return d.spatialReference=o,d})}}function et(t){return{geometryType:k(t[0]),geometries:t.map(n=>n.toJSON())}}function nt(t,n,u){const s=Q(n);return t.map(e=>{const o=s.fromJSON(e);return o.spatialReference=u,o})}async function st(t,n,u){const s=typeof t=="string"?T(t):t,e=n[0].spatialReference,o=k(n[0]),r={...u,query:{...s.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(et(n))}},{data:i}=await X(s.path+"/simplify",r);return nt(i.geometries,o,e)}const D=F.getLogger("esri.geometry.support.normalizeUtils");function ot(t){return t.type==="polygon"}function rt(t){return t[0].type==="polygon"}function it(t){return t[0].type==="polyline"}function ft(t,n){if(!(t instanceof I||t instanceof P)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw D.error(e),new _(e)}const u=j(t),s=[];for(const e of u){const o=[];s.push(o),o.push([e[0][0],e[0][1]]);for(let r=0;r<e.length-1;r++){const i=e[r][0],l=e[r][1],y=e[r+1][0],h=e[r+1][1],d=Math.sqrt((y-i)*(y-i)+(h-l)*(h-l)),a=(h-l)/d,m=(y-i)/d,p=d/n;if(p>1){for(let S=1;S<=p-1;S++){const N=S*n,f=m*N+i,c=a*N+l;o.push([f,c])}const w=(d+Math.floor(p-1)*n)/2,J=m*w+i,v=a*w+l;o.push([J,v])}o.push([y,h])}}return ot(t)?new P({rings:s,spatialReference:t.spatialReference}):new I({paths:s,spatialReference:t.spatialReference})}function z(t,n,u){if(n){const s=ft(t,1e6);t=H(s,!0)}return u&&(t=C(t,u)),t}function U(t,n,u){if(Array.isArray(t)){const s=t[0];if(s>n){const e=R(s,n);t[0]=s+e*(-2*n)}else if(s<u){const e=R(s,u);t[0]=s+e*(-2*u)}}else{const s=t.x;if(s>n){const e=R(s,n);t=t.clone().offset(e*(-2*n),0)}else if(s<u){const e=R(s,u);t=t.clone().offset(e*(-2*u),0)}}return t}function ct(t,n){let u=-1;for(let s=0;s<n.cutIndexes.length;s++){const e=n.cutIndexes[s],o=n.geometries[s],r=j(o);for(let i=0;i<r.length;i++){const l=r[i];l.some(y=>{if(y[0]<180)return!0;{let h=0;for(let a=0;a<l.length;a++){const m=l[a][0];h=m>h?m:h}h=Number(h.toFixed(9));const d=-360*R(h,180);for(let a=0;a<l.length;a++){const m=o.getPoint(i,a);o.setPoint(i,a,m.clone().offset(d,0))}return!0}})}if(e===u){if(rt(t))for(const i of j(o))t[e]=t[e].addRing(i);else if(it(t))for(const i of j(o))t[e]=t[e].addPath(i)}else u=e,t[e]=o}return t}async function ut(t,n,u){if(!Array.isArray(t))return ut([t],n);n&&typeof n!="string"&&D.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:(n==null?void 0:n.url)??W.geometryServiceUrl;let e,o,r,i,l,y,h,d,a=0;const m=[],p=[];for(const f of t)if(B(f))p.push(f);else if(e||(e=f.spatialReference,o=G(e),r=e.isWebMercator,y=r?102100:4326,i=b[y].maxX,l=b[y].minX,h=b[y].plus180Line,d=b[y].minus180Line),o)if(f.type==="mesh")p.push(f);else if(f.type==="point")p.push(U(f.clone(),i,l));else if(f.type==="multipoint"){const c=f.clone();c.points=c.points.map(g=>U(g,i,l)),p.push(c)}else if(f.type==="extent"){const c=f.clone()._normalize(!1,!1,o);p.push(c.rings?new P(c):c)}else if(f.extent){const c=f.extent,g=R(c.xmin,l)*(2*i);let x=g===0?f.clone():C(f.clone(),g);c.offset(g,0),c.intersects(h)&&c.xmax!==i?(a=c.xmax>a?c.xmax:a,x=z(x,r),m.push(x),p.push("cut")):c.intersects(d)&&c.xmin!==l?(a=c.xmax*(2*i)>a?c.xmax*(2*i):a,x=z(x,r,360),m.push(x),p.push("cut")):p.push(x)}else p.push(f.clone());else p.push(f);let w=R(a,i),J=-90;const v=w,S=new I;for(;w>0;){const f=360*w-180;S.addPath([[f,J],[f,-1*J]]),J*=-1,w--}if(m.length>0&&v>0){const f=ct(m,await tt(s,m,S,u)),c=[],g=[];for(let $=0;$<p.length;$++){const O=p[$];if(O!=="cut")g.push(O);else{const A=f.shift(),q=t[$];E(q)&&q.type==="polygon"&&q.rings&&q.rings.length>1&&A.rings.length>=q.rings.length?(c.push(A),g.push("simplify")):g.push(r?M(A):A)}}if(!c.length)return g;const x=await st(s,c,u),L=[];for(let $=0;$<g.length;$++){const O=g[$];O!=="simplify"?L.push(O):L.push(r?M(x.shift()):x.shift())}return L}const N=[];for(let f=0;f<p.length;f++){const c=p[f];if(c!=="cut")N.push(c);else{const g=m.shift();N.push(r===!0?M(g):g)}}return N}export{Y as f,$t as i,nt as o,Z as s,ut as v};
