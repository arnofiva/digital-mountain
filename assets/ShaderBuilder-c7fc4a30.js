import{r as m,t as b}from"./typedArrayUtil-70e1d79e.js";import{s as _,a as p}from"./Error-62cc7aff.js";class T{}const E=T;function f(o,...e){let t="";for(let r=0;r<e.length;r++)t+=o[r]+e[r];return t+=o[o.length-1],t}(function(o){function e(r){return Math.round(r).toString()}function t(r){return r.toPrecision(8)}o.int=e,o.float=t})(f||(f={}));var d;(function(o){o[o.Pass=0]="Pass",o[o.Draw=1]="Draw"})(d||(d={}));let k=class{constructor(e,t,r,s,i=null){this.name=e,this.type=t,this.arraySize=i,this.bind={[d.Pass]:null,[d.Draw]:null},m(r)&&m(s)&&(this.bind[r]=s)}equals(e){return this.type===e.type&&this.name===e.name&&this.arraySize===e.arraySize}};const $=_.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class g{constructor(){this._includedModules=new Map}include(e,t){if(this._includedModules.has(e)){const r=this._includedModules.get(e);if(r!==t){$.error("Trying to include shader module multiple times with different sets of options.");const s=new Set;for(const i of Object.keys(r))r[i]!==e[i]&&s.add(i);for(const i of Object.keys(e))r[i]!==e[i]&&s.add(i);s.forEach(i=>console.error(`  ${i}: current ${r[i]} new ${e[i]}`))}}else this._includedModules.set(e,t),e(this.builder,t)}}class R extends g{constructor(){super(...arguments),this.vertex=new S,this.fragment=new S,this.attributes=new v,this.varyings=new I,this.extensions=new u,this.constants=new n}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e){const t=this.extensions.generateSource(e),r=this.attributes.generateSource(e),s=this.varyings.generateSource(),i=e==="vertex"?this.vertex:this.fragment,a=i.uniforms.generateSource(),c=i.code.generateSource(),l=e==="vertex"?F:A,h=this.constants.generateSource().concat(i.constants.generateSource());return`
${t.join(`
`)}

${l}

${h.join(`
`)}

${a.join(`
`)}

${r.join(`
`)}

${s.join(`
`)}

${c.join(`
`)}`}generateBind(e,t){const r=new Map;this.vertex.uniforms.entries.forEach(a=>{const c=a.bind[e];m(c)&&r.set(a.name,c)}),this.fragment.uniforms.entries.forEach(a=>{const c=a.bind[e];m(c)&&r.set(a.name,c)});const s=Array.from(r.values()),i=s.length;return(a,c,l)=>{for(let h=0;h<i;++h)s[h](t,a,c,l)}}}class y{constructor(){this._entries=new Map}add(e){if(!Array.isArray(e))return this._add(e);for(const t of e)this._add(t)}get(e){return this._entries.get(e)}_add(e){if(b(e))$.error(`Trying to add null Uniform from ${new Error().stack}.`);else{if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new p(`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}}generateSource(){return Array.from(this._entries.values()).map(e=>m(e.arraySize)?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`)}get entries(){return Array.from(this._entries.values())}}class w{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class S extends g{constructor(){super(...arguments),this.uniforms=new y,this.code=new w,this.constants=new n}get builder(){return this}}class v{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return e==="fragment"?[]:this._entries.map(t=>`attribute ${t[1]} ${t[0]};`)}}class I{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(){return this._entries.map(e=>`varying ${e[1]} ${e[0]};`)}}class u{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t=e==="vertex"?u.ALLOWLIST_VERTEX:u.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter(r=>t.includes(r)).map(r=>`#extension ${r} : enable`)}}u.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],u.ALLOWLIST_VERTEX=[];class n{constructor(){this._entries=new Set}add(e,t,r){let s="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":s=n._numberToFloatStr(r);break;case"int":s=n._numberToIntStr(r);break;case"bool":s=r.toString();break;case"vec2":s=`vec2(${n._numberToFloatStr(r[0])},                            ${n._numberToFloatStr(r[1])})`;break;case"vec3":s=`vec3(${n._numberToFloatStr(r[0])},                            ${n._numberToFloatStr(r[1])},                            ${n._numberToFloatStr(r[2])})`;break;case"vec4":s=`vec4(${n._numberToFloatStr(r[0])},                            ${n._numberToFloatStr(r[1])},                            ${n._numberToFloatStr(r[2])},                            ${n._numberToFloatStr(r[3])})`;break;case"ivec2":s=`ivec2(${n._numberToIntStr(r[0])},                             ${n._numberToIntStr(r[1])})`;break;case"ivec3":s=`ivec3(${n._numberToIntStr(r[0])},                             ${n._numberToIntStr(r[1])},                             ${n._numberToIntStr(r[2])})`;break;case"ivec4":s=`ivec4(${n._numberToIntStr(r[0])},                             ${n._numberToIntStr(r[1])},                             ${n._numberToIntStr(r[2])},                             ${n._numberToIntStr(r[3])})`;break;case"mat2":case"mat3":case"mat4":s=`${t}(${Array.prototype.map.call(r,i=>n._numberToFloatStr(i)).join(", ")})`}return this._entries.add(`const ${t} ${e} = ${s};`),this}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const A=`#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
  precision highp sampler2D;
#else
  precision mediump float;
  precision mediump sampler2D;
#endif`,F=`precision highp float;
precision highp sampler2D;`;export{f as a,d as b,k as i,E as n,R as o};
