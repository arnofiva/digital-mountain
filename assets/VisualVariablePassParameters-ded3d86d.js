import{O as _}from"./VertexAttribute-15d1866a.js";import{C as p,A as R,u as b,U as u,B as N,P as d,t as q,F as At,M as x,G as _t,L as Rt,f as L,V as E,c as $t,n as at,Y as bt,D as Kt}from"./enums-fc527c7c.js";import{t as P}from"./VertexElementDescriptor-2925c6af.js";import{s as yt}from"./Error-62cc7aff.js";import{t as Ot,r as O,h as _e,m as wt,H as fe,q as de,P as Ee,A as Te}from"./typedArrayUtil-70e1d79e.js";import{u as Ct,E as I,a as Pt}from"./Texture-42bd3a76.js";import{r as k}from"./context-util-eb98c678.js";import"./string-7a2f1d87.js";import{n as me,i as Jt,b as Zt}from"./ShaderBuilder-c7fc4a30.js";import{e as pe}from"./mat3f64-50f3b9f6.js";import{o as Mt,_ as Ae,z as Re,n as St,r as ot}from"./vec3-015ca254.js";import{j as be,g as Vt}from"./JSONSupport-32b5ad86.js";import{h as Lt,m as xt,a as Qt}from"./mathUtils-5b623c84.js";import{a as xe,G as ge,O as Ne}from"./aaBoundingBox-dfb04110.js";import{l as Oe}from"./ViewingMode-5d7d590b.js";import{s as Fe}from"./Util-c12e93ba.js";const Gt=new Map([[_.POSITION,0],[_.NORMAL,1],[_.UV0,2],[_.COLOR,3],[_.SIZE,4],[_.TANGENT,4],[_.AUXPOS1,5],[_.SYMBOLCOLOR,5],[_.AUXPOS2,6],[_.FEATUREATTRIBUTE,6],[_.INSTANCEFEATUREATTRIBUTE,6],[_.INSTANCECOLOR,7],[_.OBJECTANDLAYERIDCOLOR,7],[_.OBJECTANDLAYERIDCOLOR_INSTANCED,7],[_.MODEL,8],[_.MODELNORMAL,12],[_.MODELORIGINHI,11],[_.MODELORIGINLO,15]]);new P(_.POSITION,3,p.FLOAT,0,12);new P(_.POSITION,3,p.FLOAT,0,20),new P(_.UV0,2,p.FLOAT,12,20);new P(_.POSITION,3,p.FLOAT,0,32),new P(_.NORMAL,3,p.FLOAT,12,32),new P(_.UV0,2,p.FLOAT,24,32);new P(_.POSITION,3,p.FLOAT,0,16),new P(_.COLOR,4,p.UNSIGNED_BYTE,12,16);const te=[new P(_.POSITION,2,p.FLOAT,0,8)],Se=[new P(_.POSITION,2,p.FLOAT,0,16),new P(_.UV0,2,p.FLOAT,8,16)];function fi(r){const t=r.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function di(r,t){return r.vertexBuffers[t].size/De(r.layout[t])}function De(r){return r[0].stride}function Ce(r,t,e,i,s=0){const n=r.gl,c=r.capabilities.instancing;r.bindBuffer(e);for(const a of i){const o=t.get(a.name);o===void 0&&console.error(`There is no location for vertex attribute '${a.name}' defined.`);const h=s*a.stride;if(a.count<=4)n.vertexAttribPointer(o,a.count,a.type,a.normalized,a.stride,a.offset+h),n.enableVertexAttribArray(o),a.divisor>0&&c&&c.vertexAttribDivisor(o,a.divisor);else if(a.count===9)for(let l=0;l<3;l++)n.vertexAttribPointer(o+l,3,a.type,a.normalized,a.stride,a.offset+12*l+h),n.enableVertexAttribArray(o+l),a.divisor>0&&c&&c.vertexAttribDivisor(o+l,a.divisor);else if(a.count===16)for(let l=0;l<4;l++)n.vertexAttribPointer(o+l,4,a.type,a.normalized,a.stride,a.offset+16*l+h),n.enableVertexAttribArray(o+l),a.divisor>0&&c&&c.vertexAttribDivisor(o+l,a.divisor);else console.error("Unsupported vertex attribute element count: "+a.count)}}function Pe(r,t,e,i){const s=r.gl,n=r.capabilities.instancing;r.bindBuffer(e);for(const c of i){const a=t.get(c.name);if(c.count<=4)s.disableVertexAttribArray(a),c.divisor&&c.divisor>0&&n&&n.vertexAttribDivisor(a,0);else if(c.count===9)for(let o=0;o<3;o++)s.disableVertexAttribArray(a+o),c.divisor&&c.divisor>0&&n&&n.vertexAttribDivisor(a+o,0);else if(c.count===16)for(let o=0;o<4;o++)s.disableVertexAttribArray(a+o),c.divisor&&c.divisor>0&&n&&n.vertexAttribDivisor(a+o,0);else console.error("Unsupported vertex attribute element count: "+c.count)}r.unbindBuffer(R.ARRAY_BUFFER)}function Be(r){switch(r){case d.ALPHA:case d.LUMINANCE:case d.RED:case d.RED_INTEGER:case u.R8:case u.R8I:case u.R8UI:case u.R8_SNORM:case N.STENCIL_INDEX8:return 1;case d.LUMINANCE_ALPHA:case d.RG:case d.RG_INTEGER:case u.RGBA4:case u.R16F:case u.R16I:case u.R16UI:case u.RG8:case u.RG8I:case u.RG8UI:case u.RG8_SNORM:case u.RGB565:case u.RGB5_A1:case N.DEPTH_COMPONENT16:return 2;case d.DEPTH_COMPONENT:case d.RGB:case d.RGB_INTEGER:case u.RGB8:case u.RGB8I:case u.RGB8UI:case u.RGB8_SNORM:case u.SRGB8:case N.DEPTH_COMPONENT24:return 3;case d.DEPTH_STENCIL:case d.RGBA:case d.RGBA_INTEGER:case u.RGBA8:case u.R32F:case u.R11F_G11F_B10F:case u.RG16F:case u.R32I:case u.R32UI:case u.RG16I:case u.RG16UI:case u.RGBA8I:case u.RGBA8UI:case u.RGBA8_SNORM:case u.SRGB8_ALPHA8:case u.RGB9_E5:case u.RGB10_A2UI:case u.RGB10_A2:case N.DEPTH_STENCIL:case N.DEPTH_COMPONENT32F:case N.DEPTH24_STENCIL8:return 4;case N.DEPTH32F_STENCIL8:return 5;case u.RGB16F:case u.RGB16I:case u.RGB16UI:return 6;case u.RG32F:case u.RG32I:case u.RG32UI:case u.RGBA16F:case u.RGBA16I:case u.RGBA16UI:return 8;case u.RGB32F:case u.RGB32I:case u.RGB32UI:return 12;case u.RGBA32F:case u.RGBA32I:case u.RGBA32UI:return 16;case b.COMPRESSED_RGB_S3TC_DXT1_EXT:case b.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case b.COMPRESSED_RGBA_S3TC_DXT3_EXT:case b.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case b.COMPRESSED_R11_EAC:case b.COMPRESSED_SIGNED_R11_EAC:case b.COMPRESSED_RGB8_ETC2:case b.COMPRESSED_SRGB8_ETC2:case b.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case b.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case b.COMPRESSED_RG11_EAC:case b.COMPRESSED_SIGNED_RG11_EAC:case b.COMPRESSED_RGBA8_ETC2_EAC:case b.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}function Ut(r){if(Ot(r))return 0;if("descriptor"in r)return r.glName?Ut(r.descriptor):0;const t=r.internalFormat||"pixelFormat"in r&&r.pixelFormat;if(!t)return 0;const e="hasMipmap"in r&&r.hasMipmap?1.3:1,i=r.width*r.height;return Be(t)*i*e}const ct=yt.getLogger("esri.views.webgl.VertexArrayObject");let ve=class{constructor(t,e,i,s,n=null){this._context=t,this._locations=e,this._layout=i,this._buffers=s,this._indexBuffer=n,this._glName=null,this._initialized=!1,t.instanceCounter.increment(q.VertexArrayObject,this)}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce((t,e)=>t+this._buffers[e].size,O(this._indexBuffer)?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(t=!0){var e,i,s;if(!this._context)return void((this._glName||t&&Object.getOwnPropertyNames(this._buffers).length>0)&&ct.warn("Leaked WebGL VAO"));if(this._glName){const n=(i=(e=this._context)==null?void 0:e.capabilities)==null?void 0:i.vao;n?(n.deleteVertexArray(this._glName),this._glName=null):ct.warn("Leaked WebGL VAO")}if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),t){for(const n in this._buffers)(s=this._buffers[n])==null||s.dispose(),delete this._buffers[n];this._indexBuffer=_e(this._indexBuffer)}this._context.instanceCounter.decrement(q.VertexArrayObject,this),this._context=wt(this._context)}initialize(){if(this._initialized)return;const t=this._context.capabilities.vao;if(t){const e=t.createVertexArray();t.bindVertexArray(e),this._bindLayout(),t.bindVertexArray(null),this._glName=e}this._initialized=!0}bind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:t,_layout:e,_indexBuffer:i}=this;t||ct.error("Vertex buffer dictionary is empty!");const s=this._context.gl;for(const n in t){const c=t[n];c||ct.error("Vertex buffer is uninitialized!");const a=e[n];a||ct.error("Vertex element descriptor is empty!"),Ce(this._context,this._locations,c,a)}O(i)&&(this._context.capabilities.vao?s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,i.glName):this._context.bindBuffer(i))}unbind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:t,_layout:e}=this;t||ct.error("Vertex buffer dictionary is empty!");for(const i in t){const s=t[i];s||ct.error("Vertex buffer is uninitialized!");const n=e[i];Pe(this._context,this._locations,s,n)}O(this._indexBuffer)&&this._context.unbindBuffer(this._indexBuffer.bufferType)}},ee=class extends ve{};const U=yt.getLogger("esri.views.webgl.BufferObject");let Ht=class lt{static createIndex(t,e,i){return new lt(t,R.ELEMENT_ARRAY_BUFFER,e,i)}static createVertex(t,e,i){return new lt(t,R.ARRAY_BUFFER,e,i)}static createUniform(t,e,i){if(t.type!==k.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new lt(t,R.UNIFORM_BUFFER,e,i)}static createPixelPack(t,e=At.STREAM_READ,i){if(t.type!==k.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const s=new lt(t,R.PIXEL_PACK_BUFFER,e);return i&&s.setSize(i),s}static createPixelUnpack(t,e=At.STREAM_DRAW,i){if(t.type!==k.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new lt(t,R.PIXEL_UNPACK_BUFFER,e,i)}constructor(t,e,i,s){this._context=t,this.bufferType=e,this.usage=i,this._glName=null,this._size=-1,this._indexType=void 0,t.instanceCounter.increment(q.BufferObject,this),this._glName=this._context.gl.createBuffer(),Ct(this._context.gl),s&&this.setData(s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteSize(){return this.bufferType===R.ELEMENT_ARRAY_BUFFER?this._indexType===p.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===R.ELEMENT_ARRAY_BUFFER||this.bufferType===R.ARRAY_BUFFER}dispose(){var t;(t=this._context)!=null&&t.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(q.BufferObject,this),this._context=wt(this._context)):this._glName&&U.warn("Leaked WebGL buffer object")}setSize(t,e=null){if(t<=0&&U.error("Buffer size needs to be positive!"),this.bufferType===R.ELEMENT_ARRAY_BUFFER&&O(e))switch(this._indexType=e,e){case p.UNSIGNED_SHORT:t*=2;break;case p.UNSIGNED_INT:t*=4}this._setBufferData(t)}setData(t){if(!t)return;let e=t.byteLength;this.bufferType===R.ELEMENT_ARRAY_BUFFER&&(fe(t)&&(e/=2,this._indexType=p.UNSIGNED_SHORT),de(t)&&(e/=4,this._indexType=p.UNSIGNED_INT)),this._setBufferData(e,t)}_setBufferData(t,e=null){this._size=t;const i=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const s=this._context.gl;O(e)?s.bufferData(this.bufferType,e,this.usage):s.bufferData(this.bufferType,t,this.usage),Ct(s),this._isVAOAware&&this._context.bindVAO(i)}setSubData(t,e,i,s){if(!t)return;(e<0||e*t.BYTES_PER_ELEMENT>=this.byteSize)&&U.error("offset is out of range!"),i>=s&&U.error("end must be bigger than start!"),(e+(s-i))*t.BYTES_PER_ELEMENT>this.byteSize&&U.error("An attempt to write beyond the end of the buffer!");const n=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const c=this._context.gl;if(this._context.type===k.WEBGL2)c.bufferSubData(this.bufferType,e*t.BYTES_PER_ELEMENT,t,i,s-i);else{const a=i===0&&s===t.length?t:t.subarray(i,s);c.bufferSubData(this.bufferType,e*t.BYTES_PER_ELEMENT,a)}Ct(c),this._isVAOAware&&this._context.bindVAO(n)}getSubData(t,e=0,i,s){if(this._context.type!==k.WEBGL2)return void U.error("Get buffer subdata is supported in WebGL2 only!");if(i<0||s<0)return void U.error("Problem getting subdata: offset and length were less than zero!");const n=Me(t)?t.BYTES_PER_ELEMENT:1;if(n*((i??0)+(s??0))>t.byteLength)return void U.error("Problem getting subdata: offset and length exceeded destination size!");e+n*(s??0)>this.byteSize&&U.warn("Potential problem getting subdata: requested data exceeds buffer size!");const c=this._context.gl;this._context.bindBuffer(this,R.COPY_READ_BUFFER),c.getBufferSubData(R.COPY_READ_BUFFER,e,t,i,s),this._context.unbindBuffer(R.COPY_READ_BUFFER)}async getSubDataAsync(t,e=0,i,s){this._context.type===k.WEBGL2?(await this._context.clientWaitAsync(),this.getSubData(t,e,i,s)):U.error("Get buffer subdata is supported in WebGL2 only!")}};function Me(r){return Ee(r)}function mi(r,t=te,e=Gt,i=-1,s=1){let n=null;return t===Se?n=new Float32Array([i,i,0,0,s,i,1,0,i,s,0,1,s,s,1,1]):n=new Float32Array([i,i,s,i,i,s,s,s]),new ee(r,e,{geometry:t},{geometry:Ht.createVertex(r,At.STATIC_DRAW,n)})}function pi(r,t=te,e=Gt){const i=new Float32Array([-1,-1,3,-1,-1,3]);return new ee(r,e,{geometry:t},{geometry:Ht.createVertex(r,At.STATIC_DRAW,i)})}const ie=4;function Ai(r,t=ie){return new I(r,{target:x.TEXTURE_2D,pixelFormat:d.RGBA,dataType:_t.UNSIGNED_BYTE,samplingMode:Rt.NEAREST,width:t,height:t})}function Ri(r,t,e=ie){const i=new Uint8Array(e*e*4);for(let s=0;s<i.length;s+=4)i[s+0]=255*t[0],i[s+1]=255*t[1],i[s+2]=255*t[2],i[s+3]=255*t[3];return new I(r,{target:x.TEXTURE_2D,pixelFormat:d.RGBA,dataType:_t.UNSIGNED_BYTE,samplingMode:Rt.NEAREST,width:e,height:e},i)}function bi(r){return new I(r,{target:x.TEXTURE_2D,pixelFormat:d.RGBA,dataType:_t.UNSIGNED_BYTE,samplingMode:Rt.NEAREST,width:1,height:1},new Uint8Array([255,255,255,255]))}let mt=class{constructor(t,e){this._context=t,this._desc=e,this.type="renderbuffer",this._context.instanceCounter.increment(q.Renderbuffer,this);const i=this._context.gl;this.glName=i.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:s,height:n,internalFormat:c,multisampled:a}=e;if(a){if(this._context.type!==k.WEBGL2)throw new Error("Multisampled renderbuffers are not supported in WebGL1!");i.renderbufferStorageMultisample(i.RENDERBUFFER,this.samples,c,s,n)}else i.renderbufferStorage(i.RENDERBUFFER,c,s,n)}get descriptor(){return this._desc}get samples(){const t=this._desc.samples,e=this._context.parameters.maxSamples;return t?Math.min(t,e):e}resize(t,e){const i=this._desc;if(i.width===t&&i.height===e)return;i.width=t,i.height=e;const s=this._context.gl;this._context.bindRenderbuffer(this),i.multisampled?s.renderbufferStorageMultisample(s.RENDERBUFFER,this.samples,i.internalFormat,i.width,i.height):s.renderbufferStorage(s.RENDERBUFFER,i.internalFormat,i.width,i.height)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(q.Renderbuffer,this),this._context=wt(this._context))}},Le=class ut{constructor(t,e,i=null,s=null){if(this._context=t,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachments=new Map,this._depthStencilTexture=null,this._initialized=!1,this._desc={...e},t.instanceCounter.increment(q.FramebufferObject,this),O(i)){Array.isArray(i)||(i=[i]);for(let n=0;n<i.length;++n){const c=i[n],a=L.COLOR_ATTACHMENT0+n;let o;Yt(c)?(Y(c)?(o=c.descriptor,this._colorAttachments.set(a,c)):(o=c,this._colorAttachments.set(a,new I(this._context,o))),gt(o,this._desc)):(Xt(c)?(o=c.descriptor,this._colorAttachments.set(a,c)):(o=c,this._colorAttachments.set(a,new mt(this._context,o))),Bt(o,this._desc)),this._validateColorAttachmentPoint(a)}}if(O(s)){let n,c;if(Yt(s))this._context.capabilities.depthTexture||console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"),Y(s)?(c=s.descriptor,this._depthStencilTexture=s):(c=s,this._depthStencilTexture=new I(this._context,c)),gt(c,this._desc);else{Xt(s)?(c=s.descriptor,n=s):(c=s,n=new mt(this._context,c));const a=this._desc.depthStencilTarget??E.DEPTH_STENCIL_RENDER_BUFFER;a===E.STENCIL_RENDER_BUFFER?this._stencilAttachment=n:a===E.DEPTH_RENDER_BUFFER||a===E.DEPTH_STENCIL_RENDER_BUFFER?this._depthAttachment=n:console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'),this._desc.depthStencilTarget=a,Bt(c,this._desc)}}}dispose(){if(!this._desc)return;const t=this._context.getBoundFramebufferObject();this._disposeColorAttachments(),this._disposeDepthStencilAttachments(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(t),this._context.instanceCounter.decrement(q.FramebufferObject,this),this._desc=null}get glName(){return this._glName}get descriptor(){return this._desc}get colorTexture(){const t=this._colorAttachments.get(L.COLOR_ATTACHMENT0);return t&&Y(t)?t:null}get colorAttachment(){return this._colorAttachments.get(L.COLOR_ATTACHMENT0)}get depthStencilAttachment(){return this._depthStencilTexture||this._depthAttachment||this._stencilAttachment}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._desc.width??0}get height(){return this._desc.height??0}get gpuMemoryUsage(){return[...this._colorAttachments].reduce((t,[e,i])=>t+Ut(i),0)+Ut(this.depthStencilAttachment)}getColorTexture(t){const e=this._colorAttachments.get(t);return e&&Y(e)?e:null}attachColorTexture(t,e=L.COLOR_ATTACHMENT0){t&&(this._validateColorAttachmentPoint(e),gt(t.descriptor,this._desc),this._disposeColorAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,e)),this._colorAttachments.set(e,t))}detachColorTexture(t=L.COLOR_ATTACHMENT0){const e=this._colorAttachments.get(t);if(Y(e)){const i=e;return this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)),this._colorAttachments.delete(t),i}}setColorTextureTarget(t,e=L.COLOR_ATTACHMENT0){const i=this._colorAttachments.get(e);Y(i)&&this._framebufferTexture2D(i.glName,e,t)}attachDepthStencilTexture(t){if(Ot(t))return;const e=t.descriptor;e.pixelFormat!==d.DEPTH_STENCIL&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),e.dataType!==_t.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),gt(e,this._desc),this._desc.depthStencilTarget&&this._desc.depthStencilTarget!==E.DEPTH_STENCIL_TEXTURE&&(this._desc.depthStencilTarget=E.DEPTH_STENCIL_TEXTURE),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,$t)),this._depthStencilTexture=t}detachDepthStencilTexture(){const t=this._depthStencilTexture;return t&&this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,$t)),this._depthStencilTexture=null,t}attachDepthStencilBuffer(t){if(Ot(t))return;const e=t.descriptor;if(e.internalFormat!==N.DEPTH_STENCIL&&e.internalFormat!==N.DEPTH_COMPONENT16&&console.error("Depth/Stencil buffer must have correct internalFormat"),Bt(e,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=e.internalFormat===N.DEPTH_STENCIL?E.DEPTH_STENCIL_RENDER_BUFFER:E.DEPTH_RENDER_BUFFER,this._initialized){this._context.bindFramebuffer(this);const i=this._context.gl,s=this._desc.depthStencilTarget===E.DEPTH_RENDER_BUFFER?i.DEPTH_ATTACHMENT:i.DEPTH_STENCIL_ATTACHMENT;i.framebufferRenderbuffer(at.FRAMEBUFFER,s,i.RENDERBUFFER,t.glName)}this._depthAttachment=t}detachDepthStencilBuffer(){const t=this._context.gl,e=this._depthAttachment;if(e&&this._initialized){this._context.bindFramebuffer(this);const i=this._desc.depthStencilTarget===E.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT;t.framebufferRenderbuffer(at.FRAMEBUFFER,i,t.RENDERBUFFER,null)}return this._depthAttachment=null,e}detachAll(){this._colorAttachments.forEach((t,e)=>this._detachColorAttachment(e)),this.detachDepthStencilBuffer(),this.detachDepthStencilTexture()}copyToTexture(t,e,i,s,n,c,a){(t<0||e<0||n<0||c<0)&&console.error("Offsets cannot be negative!"),(i<=0||s<=0)&&console.error("Copy width and height must be greater than zero!");const o=this._desc,h=a.descriptor;a.descriptor.target!==x.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),((o==null?void 0:o.width)==null||(o==null?void 0:o.height)==null||(h==null?void 0:h.width)==null||(h==null?void 0:h.height)==null||t+i>o.width||e+s>o.height||n+i>h.width||c+s>h.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const l=this._context,f=l.bindTexture(a,I.TEXTURE_UNIT_FOR_UPDATES);l.setActiveTexture(I.TEXTURE_UNIT_FOR_UPDATES),l.bindFramebuffer(this),l.gl.copyTexSubImage2D(x.TEXTURE_2D,0,n,c,t,e,i,s),l.bindTexture(f,I.TEXTURE_UNIT_FOR_UPDATES)}readPixels(t,e,i,s,n,c,a){(i<=0||s<=0)&&console.error("Copy width and height must be greater than zero!"),a||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(t,e,i,s,n,c,a)}async readPixelsAsync(t,e,i,s,n,c,a){if(this._context.type!==k.WEBGL2)return Pt()&&console.warn("Attempting to read pixels using pixel buffer object without WebGL2"),void this.readPixels(t,e,i,s,n,c,a);const o=this._context.gl,h=Ht.createPixelPack(this._context,At.STREAM_READ,a.byteLength);this._context.bindBuffer(h),this._context.bindFramebuffer(this),o.readPixels(t,e,i,s,n,c,0),this._context.unbindBuffer(R.PIXEL_PACK_BUFFER),await h.getSubDataAsync(a),h.dispose()}resize(t,e){const i=this._desc;if(i.width!==t||i.height!==e){if(i.width=t,i.height=e,!this._initialized)return this._colorAttachments.forEach(s=>{s&&s.resize(t,e)}),void(this._depthStencilTexture&&this._depthStencilTexture.resize(t,e));this._colorAttachments.forEach(s=>{s&&s.resize(t,e)}),this._depthStencilTexture!=null?this._depthStencilTexture.resize(t,e):(this._depthAttachment||this._stencilAttachment)&&(this._depthAttachment&&this._depthAttachment.resize(t,e),this._stencilAttachment&&this._stencilAttachment.resize(t,e)),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}}initializeAndBind(t=at.FRAMEBUFFER){const e=this._context.gl;if(this._initialized)return void e.bindFramebuffer(t,this.glName);this._glName&&e.deleteFramebuffer(this._glName);const i=this._context,s=e.createFramebuffer(),n=this._desc,c=n.colorTarget??bt.RENDER_BUFFER,a=n.width??1,o=n.height??1;if(e.bindFramebuffer(t,s),this._colorAttachments.size===0)if(c===bt.TEXTURE||c===bt.CUBEMAP)this._colorAttachments.set(L.COLOR_ATTACHMENT0,Ue(i,n,this.descriptor.colorTarget===bt.CUBEMAP?x.TEXTURE_CUBE_MAP:x.TEXTURE_2D));else{const l=new mt(i,{internalFormat:u.RGBA4,width:a,height:o});this._colorAttachments.set(L.COLOR_ATTACHMENT0,l)}this._colorAttachments.forEach((l,f)=>{l&&(Y(l)?this._framebufferTexture2D(l.glName,f,Wt(l),t):e.framebufferRenderbuffer(t,f,e.RENDERBUFFER,l.glName))});const h=n.depthStencilTarget??E.NONE;switch(h){case E.DEPTH_RENDER_BUFFER:case E.DEPTH_STENCIL_RENDER_BUFFER:{this._depthAttachment||(this._depthAttachment=new mt(i,{internalFormat:n.depthStencilTarget===E.DEPTH_RENDER_BUFFER?N.DEPTH_COMPONENT16:N.DEPTH_STENCIL,width:a,height:o}));const l=h===E.DEPTH_RENDER_BUFFER?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(t,l,e.RENDERBUFFER,this._depthAttachment.glName);break}case E.STENCIL_RENDER_BUFFER:this._stencilAttachment||(this._stencilAttachment=new mt(i,{internalFormat:N.STENCIL_INDEX8,width:a,height:o})),e.framebufferRenderbuffer(t,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,this._stencilAttachment.glName);break;case E.DEPTH_STENCIL_TEXTURE:if(!this._depthStencilTexture){i.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");const l={target:x.TEXTURE_2D,pixelFormat:d.DEPTH_STENCIL,dataType:_t.UNSIGNED_INT_24_8,samplingMode:Rt.NEAREST,wrapMode:Kt.CLAMP_TO_EDGE,width:a,height:o};this._depthStencilTexture=new I(i,l)}this._framebufferTexture2D(this._depthStencilTexture.glName,e.DEPTH_STENCIL_ATTACHMENT,Wt(this._depthStencilTexture),t)}Pt()&&e.checkFramebufferStatus(t)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=s,this._initialized=!0}_framebufferTexture2D(t,e=L.COLOR_ATTACHMENT0,i=x.TEXTURE_2D,s=at.FRAMEBUFFER,n=0){this._context.gl.framebufferTexture2D(s,e,i,t,n)}_detachColorAttachment(t){Pt()&&console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");const e=this._context.gl,i=this._colorAttachments.get(t);return Y(i)?this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)):this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(at.FRAMEBUFFER,t,e.RENDERBUFFER,null)),this._colorAttachments.delete(t),i}_disposeColorAttachments(){this._colorAttachments.forEach((t,e)=>{this._detachColorAttachment(e),t.dispose()}),this._colorAttachments.clear()}_disposeDepthStencilAttachments(){const t=this._context.gl;if(this._depthAttachment){if(this._initialized){this._context.bindFramebuffer(this);const e=this._desc.depthStencilTarget===E.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT;t.framebufferRenderbuffer(at.FRAMEBUFFER,e,t.RENDERBUFFER,null)}this._depthAttachment.dispose(),this._depthAttachment=null}this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(at.FRAMEBUFFER,t.STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)}_validateColorAttachmentPoint(t){if(ut._MAX_COLOR_ATTACHMENTS===-1){const i=this._context.capabilities.drawBuffers;if(i){const s=this._context.gl;ut._MAX_COLOR_ATTACHMENTS=s.getParameter(i.MAX_COLOR_ATTACHMENTS)}else ut._MAX_COLOR_ATTACHMENTS=1}const e=t-L.COLOR_ATTACHMENT0;e+1>ut._MAX_COLOR_ATTACHMENTS&&yt.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${e+1}. Implementation supports up to ${ut._MAX_COLOR_ATTACHMENTS} color attachments`)}};function Y(r){return r!=null&&"type"in r&&r.type==="texture"}function Xt(r){return r!=null&&"type"in r&&r.type==="renderbuffer"}function Yt(r){return Y(r)||r!=null&&"pixelFormat"in r}function Ue(r,t,e){return new I(r,{target:e,pixelFormat:d.RGBA,dataType:_t.UNSIGNED_BYTE,samplingMode:Rt.NEAREST,wrapMode:Kt.CLAMP_TO_EDGE,width:t.width,height:t.height})}function gt(r,t){r.target!==x.TEXTURE_2D&&r.target!==x.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),t.width!==void 0&&t.width>=0&&t.height!==void 0&&t.height>=0?t.width===r.width&&t.height===r.height||console.error("Color attachment texture must match the framebuffer's!"):(t.width=r.width,t.height=r.height)}function Bt(r,t){t.width!==void 0&&t.width>=0&&t.height!==void 0&&t.height>=0?t.width===r.width&&t.height===r.height||console.error("Renderbuffer dimensions must match the framebuffer's!"):(t.width=r.width,t.height=r.height)}function Wt(r){return r.descriptor.target===x.TEXTURE_CUBE_MAP?x.TEXTURE_CUBE_MAP_POSITIVE_X:x.TEXTURE_2D}Le._MAX_COLOR_ATTACHMENTS=-1;var Ft;(function(r){r[r.Layer=0]="Layer",r[r.Object=1]="Object",r[r.Mesh=2]="Mesh",r[r.Line=3]="Line",r[r.Point=4]="Point",r[r.Material=5]="Material",r[r.Texture=6]="Texture",r[r.COUNT=7]="COUNT"})(Ft||(Ft={}));let Ie=class{constructor(){this.id=be()}unload(){}};class Ni{constructor(){this.enabled=!0,this._time=Vt(0)}get time(){return this._time}advance({deltaTime:t,fixedTime:e}){return O(e)?this._time!==e&&(this._time=e,!0):(this._time=Vt(this._time+t),t!==0)}}let ye=class{constructor(t,e){this.deltaTime=t,this.fixedTime=e}};function Fi(r,t){return new Dt(r,ae,t)}function Si(r,t){const{curvatureDependent:e,scaleStart:i,scaleFallOffRange:s}=ae;return new Dt(r,{curvatureDependent:{min:{curvature:e.min.curvature,tiltAngle:e.min.tiltAngle,scaleFallOffFactor:vt.curvatureDependent.min.scaleFallOffFactor},max:{curvature:e.max.curvature,tiltAngle:e.max.tiltAngle,scaleFallOffFactor:vt.curvatureDependent.max.scaleFallOffFactor}},scaleStart:i,scaleFallOffRange:s,minPixelSize:vt.minPixelSize},t)}function we(r){return Math.abs(r*r*r)}function re(r,t,e){const i=e.parameters,s=e.paddingPixelsOverride;return pt.scale=Math.min(i.divisor/(t-i.offset),1),pt.factor=we(r),pt.minPixelSize=i.minPixelSize,pt.paddingPixels=s,pt}function se(r,t){return r===0?t.minPixelSize:t.minPixelSize*(1+2*t.paddingPixels/r)}function ne(r,t){return Math.max(Lt(r*t.scale,r,t.factor),se(r,t))}function Ge(r,t,e){const i=re(r,t,e);return i.minPixelSize=0,i.paddingPixels=0,ne(1,i)}function Di(r,t,e,i){i.scale=Ge(r,t,e),i.factor=0,i.minPixelSize=e.parameters.minPixelSize,i.paddingPixels=e.paddingPixelsOverride}function Ci(r,t,e=[0,0]){const i=Math.min(Math.max(t.scale,se(r[1],t)/Math.max(1e-5,r[1])),1);return e[0]=r[0]*i,e[1]=r[1]*i,e}function He(r,t,e,i){return ne(r,re(t,e,i))}class Dt{get paddingPixelsOverride(){return this._paddingPixelsOverride||this.parameters.paddingPixels}constructor(t,e,i,s=ze(),n){this._viewingMode=t,this._description=e,this._ellipsoidRadius=i,this.parameters=s,this._paddingPixelsOverride=n,this._viewingMode===Oe.Local?(this._coverageCompensation=this._surfaceCoverageCompensationLocal,this._calculateCurvatureDependentParameters=this._calculateCurvatureDependentParametersLocal):(this._coverageCompensation=this._surfaceCoverageCompensationGlobal,this._calculateCurvatureDependentParameters=this._calculateCurvatureDependentParametersGlobal)}update(t){return(!this.parameters||this.parameters.camera.fovY!==t.fovY||this.parameters.camera.distance!==t.distance)&&(this._calculateParameters(t,this._ellipsoidRadius,this.parameters),!0)}overridePadding(t){return t!==this.paddingPixelsOverride?new Dt(this._viewingMode,this._description,this._ellipsoidRadius,this.parameters,t):this}_calculateParameters(t,e,i){const{scaleStart:s,scaleFallOffRange:n,minPixelSize:c}=this._description,{fovY:a,distance:o}=t,h=this._calculateCurvatureDependentParameters(t,e),l=this._coverageCompensation(t,e,h),{tiltAngle:f,scaleFallOffFactor:g}=h,W=Math.sin(f)*o,B=.5*Math.PI-f-a*(.5-s*l),v=W/Math.cos(B),y=B+a*n*l,m=(v-g*(W/Math.cos(y)))/(1-g);return i.camera.fovY=t.fovY,i.camera.distance=t.distance,i.offset=m,i.divisor=v-m,i.minPixelSize=c,i}_calculateCurvatureDependentParametersLocal(t,e,i=jt){return i.tiltAngle=this._description.curvatureDependent.min.tiltAngle,i.scaleFallOffFactor=this._description.curvatureDependent.min.scaleFallOffFactor,i}_calculateCurvatureDependentParametersGlobal(t,e,i=jt){const s=this._description.curvatureDependent,n=1+t.distance/e,c=Math.sqrt(n*n-1),[a,o]=[s.min.curvature,s.max.curvature],h=Qt((c-a)/(o-a),0,1),[l,f]=[s.min,s.max];return i.tiltAngle=Lt(l.tiltAngle,f.tiltAngle,h),i.scaleFallOffFactor=Lt(l.scaleFallOffFactor,f.scaleFallOffFactor,h),i}_surfaceCoverageCompensationLocal(t,e,i){return(t.fovY-i.tiltAngle)/t.fovY}_surfaceCoverageCompensationGlobal(t,e,i){const s=e*e,n=i.tiltAngle+.5*Math.PI,{fovY:c,distance:a}=t,o=a*a+s-2*Math.cos(n)*a*e,h=Math.sqrt(o),l=Math.sqrt(o-s);return(Math.acos(l/h)-Math.asin(e/(h/Math.sin(n)))+.5*c)/c}}const ae={curvatureDependent:{min:{curvature:xt(10),tiltAngle:xt(12),scaleFallOffFactor:.5},max:{curvature:xt(70),tiltAngle:xt(40),scaleFallOffFactor:.8}},scaleStart:.3,scaleFallOffRange:.65,minPixelSize:0},vt={curvatureDependent:{min:{scaleFallOffFactor:.7},max:{scaleFallOffFactor:.95}},minPixelSize:14};function ze(){return{camera:{distance:0,fovY:0},divisor:0,offset:0,minPixelSize:0,paddingPixels:0}}const pt={scale:0,factor:0,minPixelSize:0,paddingPixels:0},jt={tiltAngle:0,scaleFallOffFactor:0},Nt=xe();function Pi(r,t,e,i,s,n){if(r.visible)if(r.boundingInfo){Fe(r.type===Ft.Mesh);const c=t.tolerance;ce(r.boundingInfo,e,i,c,s,n)}else{const c=r.indices.get(_.POSITION),a=r.vertexAttributes.get(_.POSITION);he(e,i,0,c.length/3,c,a,void 0,s,n)}}const $e=St();function ce(r,t,e,i,s,n){if(Ot(r))return;const c=Xe(t,e,$e);if(ge(Nt,r.bbMin),Ne(Nt,r.bbMax),O(s)&&s.applyToAabb(Nt),Ye(Nt,t,c,i)){const{primitiveIndices:a,indices:o,position:h}=r,l=a?a.length:o.length/3;if(l>qe){const f=r.getChildren();if(f!==void 0){for(const g of f)ce(g,t,e,i,s,n);return}}he(t,e,0,l,o,h,a,s,n)}}const oe=St();function he(r,t,e,i,s,n,c,a,o){if(c)return Ve(r,t,e,i,s,n,c,a,o);const{data:h,stride:l}=n,f=r[0],g=r[1],W=r[2],B=t[0]-f,v=t[1]-g,y=t[2]-W;for(let m=e,ht=3*e;m<i;++m){let A=l*s[ht++],T=h[A++],S=h[A++],D=h[A];A=l*s[ht++];let w=h[A++],K=h[A++],J=h[A];A=l*s[ht++];let Z=h[A++],Q=h[A++],tt=h[A];O(a)&&([T,S,D]=a.applyToVertex(T,S,D,m),[w,K,J]=a.applyToVertex(w,K,J,m),[Z,Q,tt]=a.applyToVertex(Z,Q,tt,m));const j=w-T,G=K-S,H=J-D,z=Z-T,$=Q-S,V=tt-D,et=v*V-$*y,ft=y*z-V*B,dt=B*$-z*v,C=j*et+G*ft+H*dt;if(Math.abs(C)<=Number.EPSILON)continue;const F=f-T,it=g-S,rt=W-D,M=F*et+it*ft+rt*dt;if(C>0){if(M<0||M>C)continue}else if(M>0||M<C)continue;const X=it*H-G*rt,Et=rt*j-H*F,Tt=F*G-j*it,st=B*X+v*Et+y*Tt;if(C>0){if(st<0||M+st>C)continue}else if(st>0||M+st<C)continue;const nt=(z*X+$*Et+V*Tt)/C;nt>=0&&o(nt,le(j,G,H,z,$,V,oe),m,!1)}}function Ve(r,t,e,i,s,n,c,a,o){const{data:h,stride:l}=n,f=r[0],g=r[1],W=r[2],B=t[0]-f,v=t[1]-g,y=t[2]-W;for(let m=e;m<i;++m){const ht=c[m];let A=3*ht,T=l*s[A++],S=h[T++],D=h[T++],w=h[T];T=l*s[A++];let K=h[T++],J=h[T++],Z=h[T];T=l*s[A];let Q=h[T++],tt=h[T++],j=h[T];O(a)&&([S,D,w]=a.applyToVertex(S,D,w,m),[K,J,Z]=a.applyToVertex(K,J,Z,m),[Q,tt,j]=a.applyToVertex(Q,tt,j,m));const G=K-S,H=J-D,z=Z-w,$=Q-S,V=tt-D,et=j-w,ft=v*et-V*y,dt=y*$-et*B,C=B*V-$*v,F=G*ft+H*dt+z*C;if(Math.abs(F)<=Number.EPSILON)continue;const it=f-S,rt=g-D,M=W-w,X=it*ft+rt*dt+M*C;if(F>0){if(X<0||X>F)continue}else if(X>0||X<F)continue;const Et=rt*z-H*M,Tt=M*G-z*it,st=it*H-G*rt,nt=B*Et+v*Tt+y*st;if(F>0){if(nt<0||X+nt>F)continue}else if(nt>0||X+nt<F)continue;const zt=($*Et+V*Tt+et*st)/F;zt>=0&&o(zt,le(G,H,z,$,V,et,oe),ht,!1)}}const kt=St(),qt=St();function le(r,t,e,i,s,n,c){return Mt(kt,r,t,e),Mt(qt,i,s,n),Ae(c,kt,qt),Re(c,c),c}function Xe(r,t,e){return Mt(e,1/(t[0]-r[0]),1/(t[1]-r[1]),1/(t[2]-r[2]))}function Ye(r,t,e,i){return We(r,t,e,i,1/0)}function We(r,t,e,i,s){const n=(r[0]-i-t[0])*e[0],c=(r[3]+i-t[0])*e[0];let a=Math.min(n,c),o=Math.max(n,c);const h=(r[1]-i-t[1])*e[1],l=(r[4]+i-t[1])*e[1];if(o=Math.min(o,Math.max(h,l)),o<0||(a=Math.max(a,Math.min(h,l)),a>o))return!1;const f=(r[2]-i-t[2])*e[2],g=(r[5]+i-t[2])*e[2];return o=Math.min(o,Math.max(f,g)),!(o<0)&&(a=Math.max(a,Math.min(f,g)),!(a>o)&&a<s)}function Bi(r,t,e,i,s){let n=(e.screenLength||0)*r.pixelRatio;O(s)&&(n=He(n,i,t,s));const c=n*Math.tan(.5*r.fovY)/(.5*r.fullHeight);return Qt(c*t,e.minWorldLength||0,e.maxWorldLength!=null?e.maxWorldLength:1/0)}function ue(r,t){const e=t?ue(t):{};for(const i in r){let s=r[i];s&&s.forEach&&(s=ke(s)),s==null&&i in e||(e[i]=s)}return e}function je(r,t){let e=!1;for(const i in t){const s=t[i];s!==void 0&&(Array.isArray(s)?r[i]===null?(r[i]=s.slice(),e=!0):Te(r[i],s)&&(e=!0):r[i]!==s&&(e=!0,r[i]=s))}return e}function ke(r){const t=[];return r.forEach(e=>t.push(e)),t}const vi={multiply:1,ignore:2,replace:3,tint:4},qe=1e3;class Mi extends Ie{constructor(t,e){super(),this.type=Ft.Material,this.supportsEdges=!1,this._visible=!0,this._renderPriority=0,this._insertOrder=0,this._vertexAttributeLocations=Gt,this._pp0=ot(0,0,1),this._pp1=ot(0,0,0),this._parameters=ue(t,e),this.validateParameters(this._parameters)}dispose(){}get parameters(){return this._parameters}update(t){return!1}setParameters(t,e=!0){je(this._parameters,t)&&(this.validateParameters(this._parameters),e&&this.parametersChanged())}validateParameters(t){}get visible(){return this._visible}set visible(t){t!==this._visible&&(this._visible=t,this.parametersChanged())}shouldRender(t){return this.isVisible()&&this.isVisibleForOutput(t.output)&&(this.renderOccluded&t.renderOccludedMask)!=0}isVisibleForOutput(t){return!0}get renderOccluded(){return this.parameters.renderOccluded}get renderPriority(){return this._renderPriority}set renderPriority(t){t!==this._renderPriority&&(this._renderPriority=t,this.parametersChanged())}get insertOrder(){return this._insertOrder}set insertOrder(t){t!==this._insertOrder&&(this._insertOrder=t,this.parametersChanged())}get vertexAttributeLocations(){return this._vertexAttributeLocations}isVisible(){return this._visible}parametersChanged(){O(this.repository)&&this.repository.materialChanged(this)}intersectDraped(t,e,i,s,n,c){return this._pp0[0]=this._pp1[0]=s[0],this._pp0[1]=this._pp1[1]=s[1],this.intersect(t,e,i,this._pp0,this._pp1,n)}}let Li=class extends ye{constructor(t,e,i){super(e,i),this.camera=t}};var It;(function(r){r[r.Occlude=1]="Occlude",r[r.Transparent=2]="Transparent",r[r.OccludeAndTransparent=4]="OccludeAndTransparent",r[r.OccludeAndTransparentStencil=8]="OccludeAndTransparentStencil",r[r.Opaque=16]="Opaque"})(It||(It={}));class Ke extends me{constructor(){super(...arguments),this.renderOccluded=It.Occlude}}class Ii extends Jt{constructor(t,e,i){super(t,"vec4",Zt.Pass,(s,n,c)=>s.setUniform4fv(t,e(n,c)),i)}}let yi=class extends Jt{constructor(t,e,i){super(t,"float",Zt.Pass,(s,n,c)=>s.setUniform1fv(t,e(n,c)),i)}};class Gi extends Ke{constructor(){super(...arguments),this.vvSizeEnabled=!1,this.vvSizeMinSize=ot(1,1,1),this.vvSizeMaxSize=ot(100,100,100),this.vvSizeOffset=ot(0,0,0),this.vvSizeFactor=ot(1,1,1),this.vvSizeValue=ot(1,1,1),this.vvColorEnabled=!1,this.vvColorValues=[0,0,0,0,0,0,0,0],this.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],this.vvOpacityEnabled=!1,this.vvOpacityValues=[0,0,0,0,0,0,0,0],this.vvOpacityOpacities=[1,1,1,1,1,1,1,1],this.vvSymbolAnchor=[0,0,0],this.vvSymbolRotationMatrix=pe()}}const Hi=8;export{Se as A,Ri as B,Ai as C,te as D,Gt as E,mt as F,pi as G,fi as H,le as I,Ii as J,Hi as K,We as L,ue as M,Bi as N,Xe as O,je as P,Ce as R,Ye as V,Be as _,Ht as a,Pe as b,Ci as c,Di as d,Ft as e,mi as f,It as g,Mi as h,Ni as i,Ie as j,Ut as k,Pi as l,vi as m,di as n,ne as o,bi as p,Fi as q,ee as r,Si as s,ve as t,Ke as u,Gi as v,Li as w,Le as x,he as y,yi as z};
